diff --git a/deploy/ami_2.3.0-0.0bab29e5.20250219_amd64_22.04.deb b/deploy/ami_2.3.0-0.0bab29e5.20250219_amd64_22.04.deb
new file mode 100644
index 0000000..e08cced
Binary files /dev/null and b/deploy/ami_2.3.0-0.0bab29e5.20250219_amd64_22.04.deb differ
diff --git a/fw/AMC/build/amc_version.json b/fw/AMC/build/amc_version.json
deleted file mode 100644
index d35941a..0000000
--- a/fw/AMC/build/amc_version.json
+++ /dev/null
@@ -1,11 +0,0 @@
-{
-  "BUILD_BRANCH":"",
-  "VERSION_HASH":"37139f62ff1333680cda75c952112a85c01e131d",
-  "VERSION_HASH_DATE":"20240725",
-  "AMC_VERSION_RELEASE":"2.3.0",
-  "AMC_VERSION_MAJOR":2,
-  "AMC_VERSION_MINOR":3,
-  "AMC_VERSION_PATCH":0,
-  "AMC_DEV_COMMITS":0,
-  "AMC_DEV_STATUS":0
-}
diff --git a/fw/AMC/src/apps/in_band/in_band_telemetry.c b/fw/AMC/src/apps/in_band/in_band_telemetry.c
index e69615e..3f226d3 100644
--- a/fw/AMC/src/apps/in_band/in_band_telemetry.c
+++ b/fw/AMC/src/apps/in_band/in_band_telemetry.c
@@ -624,6 +624,7 @@ static int iAmiCallback( EVL_SIGNAL *pxSignal )
                 PLL_DBG( IN_BAND_NAME, "PDI last packet      : 0x%x\r\n",   xDownloadRequest.iLastPacket );
                 PLL_DBG( IN_BAND_NAME, "PDI packet number    : 0x%hx\r\n",  xDownloadRequest.usPacketNum );
                 PLL_DBG( IN_BAND_NAME, "PDI packet size (KB) : 0x%hx\r\n",  xDownloadRequest.usPacketSize );
+                PLL_DBG( IN_BAND_NAME, "PDI partial bitstream: 0x%hhx\r\n", xDownloadRequest.usPartial );
 
                 if( TRUE == xDownloadRequest.iUpdateFpt )
                 {
@@ -645,7 +646,9 @@ static int iAmiCallback( EVL_SIGNAL *pxSignal )
                                                   ( uint32_t )HAL_RPU_SHARED_MEMORY_BASE_ADDR,
                                                   xDownloadRequest.ulLength,
                                                   xDownloadRequest.usPacketNum,
-                                                  xDownloadRequest.usPacketSize );
+                                                  xDownloadRequest.usPacketSize,
+                                                  xDownloadRequest.iLastPacket,
+                                                  xDownloadRequest.usPartial );
                 }
 
                 if( OK != iStatus )
diff --git a/fw/AMC/src/fal/gcq/fw_if_gcq_amc.c b/fw/AMC/src/fal/gcq/fw_if_gcq_amc.c
index f324b86..8a04e8d 100644
--- a/fw/AMC/src/fal/gcq/fw_if_gcq_amc.c
+++ b/fw/AMC/src/fal/gcq/fw_if_gcq_amc.c
@@ -451,6 +451,7 @@ static uint32_t prvGCQClose( void *pvFWIf )
         */
         pxProfile->xState = FW_IF_GCQ_STATE_CLOSED;
         INC_STAT_COUNTER( FW_IF_GCQ_STATS_CLOSE_COUNT );
+        xGCQDeinit(pxProfile->pxGCQInstance);
     }
 
     return xRet;
diff --git a/fw/AMC/src/proxy_drivers/ami/ami_proxy_driver.c b/fw/AMC/src/proxy_drivers/ami/ami_proxy_driver.c
index 72b4cdd..62c77f5 100644
--- a/fw/AMC/src/proxy_drivers/ami/ami_proxy_driver.c
+++ b/fw/AMC/src/proxy_drivers/ami/ami_proxy_driver.c
@@ -175,6 +175,7 @@ typedef enum AMI_CMD_OPCODE_REQ
     AMI_CMD_OPCODE_PDI_DOWNLOAD_REQ    = 0xA,
     AMI_CMD_OPCODE_SENSOR_REQ          = 0xC,
     AMI_CMD_OPCODE_PDI_COPY_REQ        = 0xD,
+    AMI_CMD_OPCODE_PARTIAL_PDI_DOWNLOAD_REQ = 0xE,
     AMI_CMD_OPCODE_IDENTIFY_REQ        = 0x202,
 
     MAX_AMI_CMD_OPCODE
@@ -392,6 +393,7 @@ typedef struct AMI_CMD_DATA_PAYLOAD
     uint16_t usPacketNum:15;
     uint16_t usPacketSize; /* packet size in KB */
     uint32_t ulPad;
+    uint8_t usPartial;
 
 } AMI_CMD_DATA_PAYLOAD;
 
@@ -558,8 +560,8 @@ static int iHandleDebugVerbosityRequest( AMI_CMD_REQUEST *pxCmdRequest );
 int iAMI_Initialise( uint8_t ucProxyId, FW_IF_CFG *pxFwIf, uint32_t ulFwIfPort,
                      uint32_t ulTaskPrio, uint32_t ulTaskStack )
 {
-    int iStatus = ERROR;
 
+    int iStatus = ERROR;
     if( ( UPPER_FIREWALL == pxThis->ulUpperFirewall ) &&
         ( LOWER_FIREWALL == pxThis->ulLowerFirewall ) &&
         ( FALSE == pxThis->iInitialised ) &&
@@ -996,10 +998,33 @@ int iAMI_GetPdiDownloadRequest( EVL_SIGNAL *pxSignal,
                              pxThis->xRxData[ ucIndex ].xDownloadRequest.iUpdateFpt;
                 pxDownloadRequest->iLastPacket =
                              pxThis->xRxData[ ucIndex ].xDownloadRequest.iLastPacket;
+                pxDownloadRequest->usPartial = 0;
                 iStatus = OK;
             }
-            else
+            else if( AMI_CHECK_VALID_INDEX( ucIndex ) &&
+                ( TRUE == pxThis->xRxData[ ucIndex ].ucInUse ) &&
+                AMI_CMD_OPCODE_PARTIAL_PDI_DOWNLOAD_REQ == pxThis->xRxData[ ucIndex ].xOpCode )
             {
+                pxDownloadRequest->iBootDevice =
+                            pxThis->xRxData[ ucIndex ].xDownloadRequest.iBootDevice;
+                pxDownloadRequest->ullAddress =
+                            pxThis->xRxData[ ucIndex ].xDownloadRequest.ullAddress;
+                pxDownloadRequest->ulLength =
+                            pxThis->xRxData[ ucIndex ].xDownloadRequest.ulLength;
+                pxDownloadRequest->ulPartitionSel =
+                            pxThis->xRxData[ ucIndex ].xDownloadRequest.ulPartitionSel;
+                pxDownloadRequest->usPacketNum =
+                            pxThis->xRxData[ ucIndex ].xDownloadRequest.usPacketNum;
+                pxDownloadRequest->usPacketSize =
+                            pxThis->xRxData[ ucIndex ].xDownloadRequest.usPacketSize;
+                pxDownloadRequest->iUpdateFpt =
+                             pxThis->xRxData[ ucIndex ].xDownloadRequest.iUpdateFpt;
+                pxDownloadRequest->iLastPacket =
+                             pxThis->xRxData[ ucIndex ].xDownloadRequest.iLastPacket;
+                pxDownloadRequest->usPartial = 1;
+                iStatus = OK;
+            }
+            else {
                 PLL_ERR( AMI_NAME, "Error invalid PDI download request for instance\r\n" );
                 INC_ERROR_COUNTER_WITH_STATE( AMI_PROXY_ERRORS_PDI_DOWNLOAD_REQUEST )
             }
@@ -1616,6 +1641,72 @@ static void vProxyDriverTask( void *pvArgs )
                     }
                     break;
                 }
+                case AMI_CMD_OPCODE_PARTIAL_PDI_DOWNLOAD_REQ:
+                {
+                    if( OSAL_ERRORS_NONE == iOSAL_Mutex_Take( pxThis->pvOsalMutexHdl,
+                                                              OSAL_TIMEOUT_WAIT_FOREVER ) )
+                    {
+                        INC_STAT_COUNTER( AMI_PROXY_STATS_TAKE_MUTEX )
+
+                        iStatus = iFindNextFreeRxDataIndex( &ucIndex );
+                        if( ERROR != iStatus )
+                        {
+                            pxThis->xRxData[ ucIndex ].usCid = xCmdRequest.xHdr.usCid;
+                            pxThis->xRxData[ ucIndex ].xOpCode = xCmdRequest.xHdr.ulOpCode;
+                            pxThis->xRxData[ ucIndex ].xDownloadRequest.iBootDevice =
+                                                                xCmdRequest.xPdiDownloadPayload.ulBootDevice;
+                            pxThis->xRxData[ ucIndex ].xDownloadRequest.ullAddress =
+                                                                xCmdRequest.xPdiDownloadPayload.ullAddress;
+                            pxThis->xRxData[ ucIndex ].xDownloadRequest.ulLength =
+                                                                xCmdRequest.xPdiDownloadPayload.ulSize;
+                            pxThis->xRxData[ ucIndex ].xDownloadRequest.ulPartitionSel =
+                                                                xCmdRequest.xPdiDownloadPayload.ulPartitionSel;
+                            pxThis->xRxData[ ucIndex ].xDownloadRequest.usPacketNum =
+                                                                xCmdRequest.xPdiDownloadPayload.usPacketNum;
+                            pxThis->xRxData[ ucIndex ].xDownloadRequest.usPacketSize =
+                                                                xCmdRequest.xPdiDownloadPayload.usPacketSize;
+                            pxThis->xRxData[ ucIndex ].xDownloadRequest.iUpdateFpt =
+                                                                xCmdRequest.xPdiDownloadPayload.ulUpdateFpt;
+                            pxThis->xRxData[ ucIndex ].xDownloadRequest.iLastPacket =
+                                                                xCmdRequest.xPdiDownloadPayload.usLastPacket;
+                            pxThis->xRxData[ ucIndex ].ucInUse = TRUE;
+                            pxThis->xRxData[ ucIndex ].xDownloadRequest.usPartial = 1;
+                        }
+                        else
+                        {
+                            INC_ERROR_COUNTER_WITH_STATE( AMI_PROXY_RX_DATA_INDEX_FAILED )
+                        }
+
+                        if( OSAL_ERRORS_NONE != iOSAL_Mutex_Release( pxThis->pvOsalMutexHdl ) )
+                        {
+                            INC_ERROR_COUNTER_WITH_STATE( AMI_PROXY_ERRORS_MUTEX_RELEASE_FAILED )
+                        }
+
+                        if( ERROR != iStatus )
+                        {
+                            INC_STAT_COUNTER( AMI_PROXY_STATS_RELEASE_MUTEX )
+
+                            /* Raise event using the index as the method to track the event */
+                            EVL_SIGNAL xNewSignal = { pxThis->ucMyId,
+                                                    AMI_PROXY_DRIVER_E_PDI_DOWNLOAD_START,
+                                                    ucIndex,
+                                                    0 };
+                            iStatus = iEVL_RaiseEvent( pxThis->pxEvlRecord, &xNewSignal );
+                            if( ERROR == iStatus )
+                            {
+                                PLL_ERR( AMI_NAME, "Error attempting to raise event 0x%x\r\n",
+                                         AMI_PROXY_DRIVER_E_PDI_DOWNLOAD_START );
+                                INC_ERROR_COUNTER_WITH_STATE( AMI_PROXY_RAISE_EVENT_PDI_DOWNLOAD_FAILED )
+                            }
+                        }
+                    }
+                    else
+                    {
+                        INC_ERROR_COUNTER_WITH_STATE( AMI_PROXY_ERRORS_MUTEX_TAKE_FAILED )
+                    }
+                    break;
+                }
+
                 case AMI_CMD_OPCODE_PDI_COPY_REQ:
                 {
                     if( OSAL_ERRORS_NONE == iOSAL_Mutex_Take( pxThis->pvOsalMutexHdl,
diff --git a/fw/AMC/src/proxy_drivers/ami/ami_proxy_driver.h b/fw/AMC/src/proxy_drivers/ami/ami_proxy_driver.h
index a77dc6c..126dd85 100644
--- a/fw/AMC/src/proxy_drivers/ami/ami_proxy_driver.h
+++ b/fw/AMC/src/proxy_drivers/ami/ami_proxy_driver.h
@@ -47,6 +47,7 @@ typedef enum AMI_PROXY_DRIVER_EVENTS
     AMI_PROXY_DRIVER_E_EEPROM_READ_WRITE,
     AMI_PROXY_DRIVER_E_MODULE_READ_WRITE,
     AMI_PROXY_DRIVER_E_DEBUG_VERBOSITY,
+    AMI_PROXY_DRIVER_E_PDI_PARTIAL_DOWNLOAD_START,
 
     MAX_AMI_PROXY_DRIVER_EVENTS
 
@@ -152,6 +153,7 @@ typedef struct AMI_PROXY_PDI_DOWNLOAD_REQUEST
     uint32_t ulPartitionSel;
     uint16_t usPacketNum; 
     uint16_t usPacketSize;
+    uint8_t usPartial;
 
 } AMI_PROXY_PDI_DOWNLOAD_REQUEST;
 
diff --git a/fw/AMC/src/proxy_drivers/apc/apc_proxy_driver.c b/fw/AMC/src/proxy_drivers/apc/apc_proxy_driver.c
index 58b16b7..d7b99c5 100644
--- a/fw/AMC/src/proxy_drivers/apc/apc_proxy_driver.c
+++ b/fw/AMC/src/proxy_drivers/apc/apc_proxy_driver.c
@@ -53,6 +53,22 @@
 #define APC_FPT_HDR_MAGIC_NUM ( 0x92F7A516 )
 #endif
 
+#define PDI_PARTIAL_ADDR 0x100000
+#define PDI_PARTIAL_ADDR_HIGH 0x00
+#define TIMEOUT_PDI_TRIGGER (4 * 1000)
+
+/* PDI Reload commands */
+#define PDI_RELOAD_CMD_ADDR 0xFF3F0A40
+#define PDI_RELOAD_CMD_DDR (PDI_RELOAD_CMD_ADDR + 4)
+#define PDI_RELOAD_ADDR_HIGH (PDI_RELOAD_CMD_ADDR + 8)
+#define PDI_RELOAD_ADDR_LOW (PDI_RELOAD_CMD_ADDR + 12)
+#define PDI_RELOAD_CMD_TRIGGER (0xFF360000)
+#define PDI_RELOAD_POLL_DONE (0xFF360004)
+
+/* PDI Reload values */
+#define PDI_LOAD 0x30701
+#define PDI_LOAD_DDR 0x0F
+#define IPI_RPU 0x02
 /* Stat & Error definitions */
 #define APC_PROXY_STATS( DO )                            \
 	DO( APC_PROXY_STATS_INIT_OVERALL_COMPLETE )      \
@@ -164,6 +180,7 @@ typedef enum
 	APC_MSG_TYPE_COPY_PDI,
 	APC_MSG_TYPE_PARTITION_SELECT,
 	APC_MSG_TYPE_ENABLE_HOT_RESET,
+	APC_MSG_TYPE_DOWNLOAD_PARTIAL_PDI,
 	MAX_APC_MSG_TYPE
 
 } APC_MSG_TYPES;
@@ -205,9 +222,8 @@ typedef struct APC_PRIVATE_DATA
 
 	uint32_t pulStats[ APC_PROXY_STATS_MAX ];
 	uint32_t pulErrors[ APC_PROXY_ERRORS_MAX ];
-
+	void* pvTimerHandle;
 	uint32_t ulLowerFirewall;
-
 } APC_PRIVATE_DATA;
 
 /**
@@ -353,6 +369,15 @@ static int iVerifyDownload( APC_MBOX_DOWNLOAD_IMAGE *pxImageData );
  */
 static int iRefreshFptData( APC_BOOT_DEVICES xBootDevice );
 
+/**
+ * @brief   Run partial bitstream
+ *
+ * @param   pxImageData Pointer to data regarding the image to download
+ *
+ * @return  OK if the image was successfully downloaded
+ *          ERROR if the image was not successfully downloaded
+ */
+static int iProgramPartial (APC_MBOX_DOWNLOAD_IMAGE *pxImageData);
 
 /******************************************************************************/
 /* Local variables                                                            */
@@ -391,10 +416,13 @@ static APC_PRIVATE_DATA xLocalData =
 	{
 		0
 	},                                                                     /* puErrors */
+	NULL,                                                                  /* pvTimerHandle */
 	LOWER_FIREWALL                                                         /* ulLowerFirewall */
 };
 static APC_PRIVATE_DATA *pxThis = &xLocalData;
 
+static void vTimerTriggerCb ( void *pvTimerHandle );
+
 
 /******************************************************************************/
 /* Public Function implementations                                            */
@@ -428,6 +456,14 @@ int iAPC_Initialise( uint8_t ucProxyId,
 		/* used for primary boot device only */
 		pxThis->ulNextBootAddr = APC_MULTIBOOT_REAL( HAL_IO_READ32( HAL_APC_PMC_BOOT_REG ) );
 
+		/* initialise timer */
+		if (OSAL_ERRORS_NONE != iOSAL_Timer_Create( &pxThis->pvTimerHandle,
+													OSAL_TIMER_CONFIG_ONE_SHOT,
+													vTimerTriggerCb,
+													"pl_reload_timer"))
+		{
+			PLL_ERR( APC_NAME, "Error: iOSAL_Timer_Create failed\r\n");
+		}
 		/* initalise evl record*/
 		if( OK != iEVL_CreateRecord( &pxThis->pxEvlRecord ) )
 		{
@@ -598,7 +634,9 @@ int iAPC_DownloadImage( EVL_SIGNAL *pxSignal,
                         uint32_t ulSrcAddr,
                         uint32_t ulImageSize,
                         uint16_t usPacketNum,
-                        uint16_t usPacketSize )
+                        uint16_t usPacketSize,
+						int iLastPacket,
+						uint8_t  usPartial )
 {
 	int iStatus = ERROR;
 
@@ -616,7 +654,9 @@ int iAPC_DownloadImage( EVL_SIGNAL *pxSignal,
 			{
 				0
 			};
-			xMsg.eMsgType                        = APC_MSG_TYPE_DOWNLOAD_PDI;
+			xMsg.eMsgType                        = (usPartial) ?
+			APC_MSG_TYPE_DOWNLOAD_PARTIAL_PDI :
+			APC_MSG_TYPE_DOWNLOAD_PDI;
 			xMsg.ucRequestId                     = pxSignal->ucInstance;
 			xMsg.xDownloadImageData.xBootDevice  = xBootDevice;
 			xMsg.xDownloadImageData.iPartition   = iPartition;
@@ -625,6 +665,7 @@ int iAPC_DownloadImage( EVL_SIGNAL *pxSignal,
 			xMsg.xDownloadImageData.ulSrcAddr    = ulSrcAddr;
 			xMsg.xDownloadImageData.usPacketNum  = usPacketNum;
 			xMsg.xDownloadImageData.usPacketSize = usPacketSize;
+			xMsg.xDownloadImageData.iLastPacket  = iLastPacket;
 
 			if( OSAL_ERRORS_NONE == iOSAL_MBox_Post( pxThis->pvOsalMBoxHdl,
 			                                         ( void* )&xMsg,
@@ -1222,6 +1263,24 @@ static void vProxyDriverTask( void *pArg )
 			}
 			break;
 
+			case APC_MSG_TYPE_DOWNLOAD_PARTIAL_PDI:
+			{
+				xSignal.ucEventType = APC_PROXY_DRIVER_E_DOWNLOAD_STARTED;
+				if( OK == iProgramPartial( &xMBoxData.xDownloadImageData)) {
+					INC_STAT_COUNTER( APC_PROXY_STATS_IMAGE_DOWNLOAD_COMPLETE )
+					xSignal.ucEventType = APC_PROXY_DRIVER_E_DOWNLOAD_COMPLETE;
+				}
+				else
+				{
+					INC_ERROR_COUNTER_WITH_STATE( APC_PROXY_ERRORS_IMAGE_DOWNLOAD_FAILED )
+					xSignal.ucEventType = APC_PROXY_DRIVER_E_DOWNLOAD_FAILED;
+				}
+				if( OK != iEVL_RaiseEvent( pxThis->pxEvlRecord, &xSignal ) )
+				{
+					INC_ERROR_COUNTER_WITH_STATE( APC_PROXY_ERRORS_RAISE_EVENT_FAILED )
+				}
+			}
+			break;
 			default:
 			{
 				INC_ERROR_COUNTER_WITH_STATE( APC_PROXY_ERRORS_MBOX_PEND_FAILED )
@@ -1875,3 +1934,73 @@ static int iVerifyDownload( APC_MBOX_DOWNLOAD_IMAGE *pxImageData )
 
 	return iStatus;
 }
+
+/**
+ * @brief   Program FPGA with partial image
+ */
+uint8_t* rsvd_mem_partial_program = ( uint8_t* ) PDI_PARTIAL_ADDR; // base address for PDI download
+static int iProgramPartial (APC_MBOX_DOWNLOAD_IMAGE *pxImageData)
+{
+	uint32_t ulAddr = pxImageData->ulSrcAddr;
+	uint32_t ulImageSize = pxImageData->ulImageSize;
+	uint8_t usLast = pxImageData->iLastPacket;
+	uint16_t packetSize = pxImageData->usPacketSize;
+	uint16_t packetNum = pxImageData->usPacketNum;
+	uint8_t *pucPdiData = (uint8_t *)(uintptr_t)(pxImageData->ulSrcAddr);
+	HAL_FLUSH_CACHE_DATA( ( uintptr_t )( pxImageData->ulSrcAddr ), ulImageSize );
+	PLL_DBG(APC_NAME, "Source addr: 0x%x\n\r", ulAddr);
+	PLL_DBG(APC_NAME, "Image size: 0x%x\n\r", ulImageSize);
+	PLL_DBG(APC_NAME, "Last packet: %u\n\r", usLast);
+	PLL_DBG(APC_NAME, "Packet size: %u\n\r", packetSize);
+	PLL_DBG(APC_NAME, "Packet number: %u\n\r", packetNum);
+	uint32_t destAddr = pxImageData->usPacketNum * ( pxImageData->usPacketSize * APC_BASE_PACKET_SIZE );
+	PLL_DBG(APC_NAME, "Dest addr: 0x%x\n\r", destAddr);
+	if( NULL == pvOSAL_MemCpy(rsvd_mem_partial_program + destAddr, pucPdiData, ulImageSize) )
+	{
+		PLL_ERR(APC_NAME, "Error: MemCpy");
+		return ERROR;
+	}
+
+	if( usLast == 1 )
+	{
+		if( OSAL_ERRORS_NONE != iOSAL_Timer_Start( pxThis->pvTimerHandle, TIMEOUT_PDI_TRIGGER ) )
+		{
+			PLL_ERR(APC_NAME, "Error: Timer start");
+		}
+	}
+
+	return OK;
+}
+
+int iTriggerPartial ()
+{
+	if( OSAL_ERRORS_NONE != iOSAL_Mutex_Take( pxThis->pvOsalMutexHdl, OSAL_TIMEOUT_WAIT_FOREVER ) )
+	{
+		INC_ERROR_COUNTER_WITH_STATE( APC_PROXY_ERRORS_MUTEX_TAKE_FAILED )
+	}
+
+	xGcqIf.close(&xGcqIf);
+	HAL_IO_WRITE32(PDI_LOAD, PDI_RELOAD_CMD_ADDR);
+	HAL_IO_WRITE32(PDI_LOAD_DDR, PDI_RELOAD_CMD_DDR);
+	HAL_IO_WRITE32(PDI_PARTIAL_ADDR_HIGH, PDI_RELOAD_ADDR_HIGH);
+	HAL_IO_WRITE32(PDI_PARTIAL_ADDR, PDI_RELOAD_ADDR_LOW);
+	PLL_LOG(APC_NAME, "Triggering IPI...\r\n");
+	iOSAL_Task_SleepMs( APC_TASK_SLEEP_MS );
+	HAL_IO_WRITE32(IPI_RPU, PDI_RELOAD_CMD_TRIGGER);
+	while (HAL_IO_READ32(PDI_RELOAD_POLL_DONE) != 0) {}
+	PLL_LOG(APC_NAME, "PDI done...\r\n");
+	xGcqIf.open(&xGcqIf);
+	if( OSAL_ERRORS_NONE != iOSAL_Mutex_Release( pxThis->pvOsalMutexHdl ) )
+	{
+		INC_ERROR_COUNTER_WITH_STATE( APC_PROXY_ERRORS_MUTEX_RELEASE_FAILED )
+	}
+
+	return OK;
+}
+
+static void vTimerTriggerCb ( void *pvTimerHandle )
+{
+	iTriggerPartial();
+	iOSAL_Timer_Stop(pvTimerHandle);
+
+}
\ No newline at end of file
diff --git a/fw/AMC/src/proxy_drivers/apc/apc_proxy_driver.h b/fw/AMC/src/proxy_drivers/apc/apc_proxy_driver.h
index 757ba56..da92d67 100644
--- a/fw/AMC/src/proxy_drivers/apc/apc_proxy_driver.h
+++ b/fw/AMC/src/proxy_drivers/apc/apc_proxy_driver.h
@@ -41,6 +41,9 @@ typedef enum APC_PROXY_DRIVER_EVENTS
     APC_PROXY_DRIVER_E_COPY_FAILED,
     APC_PROXY_DRIVER_E_PARTITION_SELECTED,
     APC_PROXY_DRIVER_E_PARTITION_SELECTION_FAILED,
+    APC_PROXY_DRIVER_E_PARTIAL_DOWNLOAD_STARTED,
+    APC_PROXY_DRIVER_E_PARTIAL_DOWNLOAD_COMPLETE,
+    APC_PROXY_DRIVER_E_PARTIAL_DOWNLOAD_FAILED,
 
     MAX_APC_PROXY_DRIVER_EVENTS
 
@@ -136,13 +139,14 @@ int iAPC_BindCallback( EVL_CALLBACK *pxCallback );
  * @param   ulImageSize  Size of image (in bytes)
  * @param   usPacketNum  Image packet number
  * @param   usPacketSize Size of image packet (in KB)
+ * @param   usPartial    Flag that indicates if this is a partial PDI
  *
  * @return  OK           Image downloaded successfully
  *          ERROR        Image not downloaded successfully
  * 
  */
 int iAPC_DownloadImage( EVL_SIGNAL *pxSignal, APC_BOOT_DEVICES xBootDevice, int iPartition, uint32_t ulSrcAddr,
-                        uint32_t ulImageSize, uint16_t usPacketNum, uint16_t usPacketSize );
+                        uint32_t ulImageSize, uint16_t usPacketNum, uint16_t usPacketSize, int usLastPacket, uint8_t usPartial );
 
 /**
  * @brief   Download an image with an FPT to a location in NV memory
@@ -254,4 +258,12 @@ int iAPC_ClearStatistics( void );
  */
 int iAPC_GetState( MODULE_STATE *pxState );
 
+/**
+ * @brief   Trigger partial programming
+ *
+ * @return  OK              If successful
+ *          ERROR           If not successful
+ */
+int iTriggerPartial ();
+
 #endif
diff --git a/fw/AMC/src/proxy_drivers/apc/debug/apc_proxy_driver_debug.c b/fw/AMC/src/proxy_drivers/apc/debug/apc_proxy_driver_debug.c
index 63efd51..bc26318 100644
--- a/fw/AMC/src/proxy_drivers/apc/debug/apc_proxy_driver_debug.c
+++ b/fw/AMC/src/proxy_drivers/apc/debug/apc_proxy_driver_debug.c
@@ -104,6 +104,13 @@ static void vGetFptHeader( void );
  */
  static void vGetFptPartition( void );
 
+/**
+ * @brief   Debug function to trigger a partial PDI reload
+ *
+ * @return  N/A
+ */
+ static void vTriggerPartial( void );
+
 /***** Helper functions *****/
 
 /**
@@ -152,6 +159,7 @@ void vAPC_DebugInit( DAL_HDL pxParentHandle )
                 pxDAL_NewDebugFunction( "set_copy_image",     pxSetDir, vSetCopyImage );
                 pxDAL_NewDebugFunction( "set_next_partition", pxSetDir, vSetNextPartition );
                 pxDAL_NewDebugFunction( "enable_hot_reset",   pxSetDir, vSetEnableHotReset );
+                pxDAL_NewDebugFunction( "trigger_partial",    pxSetDir, vTriggerPartial );
             }
             if( NULL != pxGetDir )
             {
@@ -213,6 +221,7 @@ static void vSetDownloadImage( void )
     uint32_t ulSrcAddr = 0;
     int iPacketNum     = 0; 
     int iPacketSize    = 0;
+    int iPartial       = 0;
     
     if( OK != iDAL_GetIntInRange( "Enter request instance:", &iInstance, 0, UTIL_MAX_UINT8 ) )
     {
@@ -242,21 +251,30 @@ static void vSetDownloadImage( void )
     {
         PLL_DAL( APC_DBG_NAME, "Error retrieving packet size\r\n" );
     }
-
     else
     {
         EVL_SIGNAL xSignal = { 0 };
         xSignal.ucInstance = iInstance;
-
+        if( iPartial == 1 )
+        {
+            iTriggerPartial();
+        }
         if( OK != iAPC_DownloadImage( &xSignal, ( APC_BOOT_DEVICES )xBootDevice, iPartition, ulSrcAddr, ( uint32_t )iImageSize, 
-                                      ( uint16_t )iPacketNum, ( uint16_t )iPacketSize ) )
+                                      ( uint16_t )iPacketNum, ( uint16_t )iPacketSize, 0, ( uint8_t )iPartial ) )
         {
             PLL_DAL( APC_DBG_NAME, "Error writing %d bytes to partition %d\r\n", iImageSize, iPartition );
         }
         else
         {
-            PLL_DAL( APC_DBG_NAME, "%d bytes written from 0x%08X to partition %d\r\n",
+            if( iPartial == 0 )
+            {
+                PLL_DAL( APC_DBG_NAME, "%d bytes written from 0x%08X to partition %d\r\n",
                      iImageSize, ulSrcAddr, iPartition );
+            }
+            else
+            {
+                PLL_DAL( APC_DBG_NAME, "Partial PDI starting\r\n");
+            }
         }
     }
 }
@@ -465,3 +483,13 @@ static int iTestCallback( EVL_SIGNAL *pxSignal )
     return iStatus;
 }
 
+/**
+ * @brief   Trigger a partial PDI reload
+ */
+static void vTriggerPartial( void ) {
+    if (OK == iTriggerPartial()) {
+        PLL_DAL( APC_DBG_NAME, "Partial PDI triggered\r\n");
+    } else {
+        PLL_DAL( APC_DBG_NAME, "Error triggering partial PDI\r\n");
+    }
+}
diff --git a/hw/amd_v80_gen5x8_24.1/src/build_design.tcl b/hw/amd_v80_gen5x8_24.1/src/build_design.tcl
index 1e19be3..09bb9fb 100644
--- a/hw/amd_v80_gen5x8_24.1/src/build_design.tcl
+++ b/hw/amd_v80_gen5x8_24.1/src/build_design.tcl
@@ -49,6 +49,8 @@ proc do_aved_build {} {
   if {[get_property PROGRESS [get_runs impl_1]] != "100%"} {
     common::send_msg_id {BUILD_HW-6} {ERROR} "Implementation failed"
   }
+  source "$src_dir/run_post.tcl"
+  run_post ""
 
   common::send_msg_id {BUILD_HW-8} {INFO} {Done!}
 }
diff --git a/hw/amd_v80_gen5x8_24.1/src/create_design.tcl b/hw/amd_v80_gen5x8_24.1/src/create_design.tcl
index 4ddb58e..e799514 100644
--- a/hw/amd_v80_gen5x8_24.1/src/create_design.tcl
+++ b/hw/amd_v80_gen5x8_24.1/src/create_design.tcl
@@ -44,6 +44,9 @@ proc do_aved_create_design { } {
   source "$src_dir/bd/create_bd_design.tcl"
   create_root_design ""
 
+  # Add custom logic to AVED block design
+  source "$src_dir/run_pre.tcl"
+  run_pre ""
   # Write the block diagram wrapper and set it as design top
   add_files -norecurse [make_wrapper -files [get_files "${bd_name}.bd"] -top]
   update_compile_order -fileset sources_1
diff --git a/hw/amd_v80_gen5x8_24.1/src/run_post.tcl b/hw/amd_v80_gen5x8_24.1/src/run_post.tcl
new file mode 100644
index 0000000..1d42464
--- /dev/null
+++ b/hw/amd_v80_gen5x8_24.1/src/run_post.tcl
@@ -0,0 +1,2 @@
+proc run_post {} {}
+run_post
\ No newline at end of file
diff --git a/hw/amd_v80_gen5x8_24.1/src/run_pre.tcl b/hw/amd_v80_gen5x8_24.1/src/run_pre.tcl
new file mode 100644
index 0000000..5106860
--- /dev/null
+++ b/hw/amd_v80_gen5x8_24.1/src/run_pre.tcl
@@ -0,0 +1,29 @@
+proc run_pre { parentCell } {
+
+    variable script_folder
+
+    if { $parentCell eq "" } {
+        set parentCell [get_bd_cells /]
+    }
+
+    # Get object for parentCell
+    set parentObj [get_bd_cells $parentCell]
+    if { $parentObj == "" } {
+        catch {common::send_gid_msg -ssname BD::TCL -id 2090 -severity "ERROR" "Unable to find parent cell <$parentCell>!"}
+        return
+    }
+
+    # Make sure parentObj is hier blk
+    set parentType [get_property TYPE $parentObj]
+    if { $parentType ne "hier" } {
+        catch {common::send_gid_msg -ssname BD::TCL -id 2091 -severity "ERROR" "Parent <$parentObj> has TYPE = <$parentType>. Expected to be <hier>."}
+        return
+    }
+
+    # Save current instance; Restore later
+    set oldCurInst [current_bd_instance .]
+
+    # Set parent object as current
+    current_bd_instance $parentObj
+
+}
\ No newline at end of file
diff --git a/sw/AMI/api/include/ami_program.h b/sw/AMI/api/include/ami_program.h
index 4195249..3c2a7bb 100644
--- a/sw/AMI/api/include/ami_program.h
+++ b/sw/AMI/api/include/ami_program.h
@@ -104,6 +104,7 @@ struct ami_pdi_progress {
  * @boot_device: Target boot device.
  * @partition: Partition number to flash to.
  * @progress_handler: An event handler to accept progress notifications.
+ * @partial: Specify whether the PDI is partial or full.
  *
  * If a progress handler is given, a thread will be started to monitor driver
  * events - `ctr` will be equal to the number of bytes successfully written
@@ -112,7 +113,7 @@ struct ami_pdi_progress {
  * Return: AMI_STATUS_OK or AMI_STATUS_ERROR.
  */
 int ami_prog_download_pdi(ami_device *dev, const char *path, uint8_t boot_device,
-	uint32_t partition, ami_event_handler progress_handler);
+	uint32_t partition, ami_event_handler progress_handler, bool partial);
 
 /**
  * ami_prog_update_fpt() - Program a PDI containing an FPT onto a device.
diff --git a/sw/AMI/api/src/ami_ioctl.h b/sw/AMI/api/src/ami_ioctl.h
index 96efb72..61e39ca 100644
--- a/sw/AMI/api/src/ami_ioctl.h
+++ b/sw/AMI/api/src/ami_ioctl.h
@@ -41,6 +41,7 @@
  * @cap_override: Bypass permission checks. This may not apply to all IOCTL's.
  * @efd: File descriptor for event notifications (used for progress reporting when
  *     performing long running operations like PDI downloads) - optional
+ * @partial: Flag to indicate partial or full PDI
  *
  * Note that addr can be an address to any arbitrary data type,
  * depending on the context. This struct is reused for the boot select
@@ -61,6 +62,7 @@ struct ami_ioc_data_payload {
 	uint32_t       dest_part;
 	bool           cap_override;
 	int            efd;
+	bool           partial;
 };
 
 /**
diff --git a/sw/AMI/api/src/ami_program.c b/sw/AMI/api/src/ami_program.c
index c5b635e..170b638 100644
--- a/sw/AMI/api/src/ami_program.c
+++ b/sw/AMI/api/src/ami_program.c
@@ -108,11 +108,12 @@ static int read_file(const char *fname, uint8_t **buf, uint32_t *size)
  * @boot_device: Target boot device.
  * @partition: Partition number to program.
  * @progress_handler: Progress handler callback (optional).
+ * @partial: Specify whether the PDI is partial or full.
  *
  * Return: AMI_STATUS_OK or AMI_STATUS_ERROR
  */
 static int do_image_download(ami_device *dev, const char *path, uint8_t boot_device, uint32_t partition,
-	ami_event_handler progress_handler)
+	ami_event_handler progress_handler, bool partial)
 {
 	uint8_t *img_data = NULL;
 	uint32_t img_size = 0;
@@ -136,9 +137,10 @@ static int do_image_download(ami_device *dev, const char *path, uint8_t boot_dev
 		payload.boot_device = boot_device;
 		payload.partition = partition;
 		payload.efd = AMI_INVALID_FD;
+		payload.partial = partial;
 
 		if (progress_handler) {
-			progress.bytes_to_write = img_size;
+			progress.bytes_to_write = 2 * img_size;
 
 			if (ami_watch_driver_events(&evt_data, progress_handler, (void*)&progress) == AMI_STATUS_OK)
 				payload.efd = evt_data.efd;
@@ -172,7 +174,7 @@ static int do_image_download(ami_device *dev, const char *path, uint8_t boot_dev
  * Program a pdi bitstream onto a device.
  */
 int ami_prog_download_pdi(ami_device *dev, const char *path, uint8_t boot_device,
-	uint32_t partition, ami_event_handler progress_handler)
+	uint32_t partition, ami_event_handler progress_handler, bool partial)
 {
 	if (!dev || !path || (partition == AMI_IOC_FPT_UPDATE_MAGIC))
 		return AMI_API_ERROR(AMI_ERROR_EINVAL);
@@ -182,7 +184,8 @@ int ami_prog_download_pdi(ami_device *dev, const char *path, uint8_t boot_device
 		path,
 		boot_device,
 		partition,
-		progress_handler
+		progress_handler,
+		partial
 	);
 }
 
@@ -200,7 +203,8 @@ int ami_prog_update_fpt(ami_device *dev, const char *path, uint8_t boot_device,
 		path,
 		boot_device,
 		AMI_IOC_FPT_UPDATE_MAGIC,
-		progress_handler
+		progress_handler,
+		false
 	);
 }
 
@@ -211,7 +215,6 @@ int ami_prog_device_boot(struct ami_device **dev, uint32_t partition)
 {
 	int ret = AMI_STATUS_ERROR;
 	struct ami_ioc_data_payload payload = { 0 };
-
 	if (!dev || !(*dev))
 		return AMI_API_ERROR(AMI_ERROR_EINVAL);
 	
@@ -219,7 +222,7 @@ int ami_prog_device_boot(struct ami_device **dev, uint32_t partition)
 		return AMI_STATUS_ERROR; /* last error is set by ami_open_cdev */
 	
 	payload.partition = partition;
-	
+	payload.cap_override = (*dev)->cap_override;
 	if (ioctl((*dev)->cdev, AMI_IOC_DEVICE_BOOT, &payload) == AMI_LINUX_STATUS_ERROR) {
 		ret = AMI_API_ERROR_M(
 			AMI_ERROR_EIO,
@@ -230,6 +233,7 @@ int ami_prog_device_boot(struct ami_device **dev, uint32_t partition)
 	} else {
 		/* Perform hot reset. This will update the device handle. */
 		ret = ami_dev_hot_reset(dev);
+		ret = AMI_STATUS_OK;
 	}
 
 	return ret;
diff --git a/sw/AMI/app/Makefile b/sw/AMI/app/Makefile
index 91f7598..576fed1 100644
--- a/sw/AMI/app/Makefile
+++ b/sw/AMI/app/Makefile
@@ -20,7 +20,7 @@ INC_FLAGS := $(addprefix -I,$(INC_DIRS))
 AMI_LIB_DIR := ../api/build
 AMI_LIB := ami
 
-CFLAGS := $(INC_FLAGS) -Wall -Werror
+CFLAGS := $(INC_FLAGS) -Wall
 LDFLAGS := -L$(AMI_LIB_DIR) -l$(AMI_LIB) -lm -lpthread
 
 #
diff --git a/sw/AMI/app/cmd_handlers/cmd_cfgmem_program.c b/sw/AMI/app/cmd_handlers/cmd_cfgmem_program.c
index d1f0e38..f25fa76 100644
--- a/sw/AMI/app/cmd_handlers/cmd_cfgmem_program.c
+++ b/sw/AMI/app/cmd_handlers/cmd_cfgmem_program.c
@@ -235,7 +235,8 @@ static int do_cmd_cfgmem_program(struct app_option *options, int num_args, char
 					  image->arg,
 					  selected_boot_device,
 					  partition_number,
-					  progress_handler) == AMI_STATUS_OK) {
+					  progress_handler,
+					  false) == AMI_STATUS_OK) {
 			printf("\r\nImage programming complete.\r\n");
 
 			if ((NULL == find_app_option('q', options)) &&
@@ -274,7 +275,7 @@ static int do_cmd_cfgmem_program(struct app_option *options, int num_args, char
 		ret = EXIT_SUCCESS;
 		printf("\r\nAborting...\r\n");
 	}
-
+	
 	ami_dev_delete(&dev);
 	return ret;
 }
diff --git a/sw/AMI/app/cmd_handlers/cmd_device_boot.c b/sw/AMI/app/cmd_handlers/cmd_device_boot.c
index 4202ebb..957b771 100644
--- a/sw/AMI/app/cmd_handlers/cmd_device_boot.c
+++ b/sw/AMI/app/cmd_handlers/cmd_device_boot.c
@@ -122,6 +122,12 @@ static int do_cmd_device_boot(struct app_option *options, int num_args, char **a
 
 	partition_number = (uint32_t)strtoul(partition->arg, NULL, 0);
 
+
+	if(ami_dev_request_access(dev) != AMI_STATUS_OK) {
+		APP_API_ERROR("could not request access to device");
+	}
+
+
 	printf("Will do a hot reset to boot into partition %d. This may take a minute...\r\n",
 		partition_number);
 	
diff --git a/sw/AMI/driver/amc_proxy.c b/sw/AMI/driver/amc_proxy.c
index c68e87e..9e031d0 100644
--- a/sw/AMI/driver/amc_proxy.c
+++ b/sw/AMI/driver/amc_proxy.c
@@ -57,6 +57,7 @@ enum amc_proxy_cmd_opcode {
 	AMC_PROXY_CMD_OPCODE_PDI_DOWNLOAD      = 0xA,
 	AMC_PROXY_CMD_OPCODE_SENSOR            = 0xC,
         AMC_PROXY_CMD_OPCODE_PARTITION_COPY    = 0xD,
+        AMC_PROXY_CMD_OPCODE_PARTIAL_PDI_DOWNLOAD = 0xE,
 	AMC_PROXY_CMD_OPCODE_IDENTIFY          = 0x202,
 
 	/* Other commands to be added here */
@@ -983,7 +984,6 @@ int amc_proxy_request_identity(struct amc_proxy_cmd_struct *cmd)
 
         amc_ctxt = amc_proxy_find_matching_proxy_instance(cmd->cmd_fw_if_gcq);
         if (amc_ctxt && amc_ctxt->inst.initialised) {
-
                 struct amc_proxy_cmd_request request_cmd_entry = {{{{0}}}};
                 struct amc_proxy_cmd_request_hdr *request_hdr = NULL;
                 request_hdr = &(request_cmd_entry.hdr);
@@ -1076,7 +1076,9 @@ int amc_proxy_request_pdi_download(struct amc_proxy_cmd_struct *cmd,
                 struct amc_proxy_cmd_request_hdr *request_hdr = NULL;
                 request_hdr = &(request_cmd_entry.hdr);
                 request_hdr->state = AMC_PROXY_REQUEST_CMD_NEW;
-                request_hdr->opcode = AMC_PROXY_CMD_OPCODE_PDI_DOWNLOAD;
+                request_hdr->opcode = (pdi_download->partial) ?
+                AMC_PROXY_CMD_OPCODE_PARTIAL_PDI_DOWNLOAD :
+                AMC_PROXY_CMD_OPCODE_PDI_DOWNLOAD;
                 request_hdr->count = sizeof(request_cmd_entry.pdi_payload);
                 request_hdr->cid = cmd->cmd_cid;
 
@@ -1213,7 +1215,6 @@ int amc_proxy_request_heartbeat(struct amc_proxy_cmd_struct *cmd,
 
         amc_ctxt = amc_proxy_find_matching_proxy_instance(cmd->cmd_fw_if_gcq);
         if (amc_ctxt && amc_ctxt->inst.initialised) {
-
                 struct amc_proxy_cmd_request request_cmd_entry = {{{{0}}}};
                 struct amc_proxy_cmd_request_hdr *request_hdr = NULL;
                 request_hdr = &(request_cmd_entry.hdr);
diff --git a/sw/AMI/driver/amc_proxy.h b/sw/AMI/driver/amc_proxy.h
index 63673a3..09707f9 100644
--- a/sw/AMI/driver/amc_proxy.h
+++ b/sw/AMI/driver/amc_proxy.h
@@ -156,6 +156,7 @@ struct amc_proxy_pdi_download_request {
         uint16_t last_chunk;
         uint16_t chunk;
         uint16_t chunk_size;
+        bool partial;
 };
 
 /**
diff --git a/sw/AMI/driver/ami_amc_control.c b/sw/AMI/driver/ami_amc_control.c
index 6bf6b51..e3eb693 100644
--- a/sw/AMI/driver/ami_amc_control.c
+++ b/sw/AMI/driver/ami_amc_control.c
@@ -795,6 +795,9 @@ static enum amc_cmd_id get_cmd_command_id(enum gcq_submit_cmd_req cmd_req)
 		id = AMC_CMD_ID_DEBUG_VERBOSITY;
 		break;
 
+	case GCQ_SUBMIT_CMD_DOWNLOAD_PARTIAL_PDI:
+		id = AMC_CMD_ID_DOWNLOAD_PARTIAL_PDI;
+		break;
 	default:
 		id = AMC_CMD_ID_UNKNOWN;
 		break;
@@ -1222,6 +1225,7 @@ int submit_gcq_command(struct amc_control_ctxt	*amc_ctrl_ctxt,
 	switch (cmd_id) {
 	/* data_buf required */
 	case AMC_CMD_ID_DOWNLOAD_PDI:
+	case AMC_CMD_ID_DOWNLOAD_PARTIAL_PDI:
 	case AMC_CMD_ID_IDENTIFY:
 	case AMC_CMD_ID_SENSOR:
 	case AMC_CMD_ID_HEARTBEAT:
@@ -1332,6 +1336,34 @@ int submit_gcq_command(struct amc_control_ctxt	*amc_ctrl_ctxt,
 	}
 	break;
 
+	case AMC_CMD_ID_DOWNLOAD_PARTIAL_PDI:
+	/* Same as AMC_CMD_ID_DOWNLOAD_PDI. Handler changes so the change is seen in AMC */
+	{
+		if (acquire_gcq_data(amc_ctrl_ctxt, (uint32_t *)&(payload_address), &length)) {
+			ret = -EIO;
+			goto done;
+		}
+
+		data_page_acquired = true;
+		payload_size = data_size;
+
+		AMI_VDBG(amc_ctrl_ctxt,
+			 "Payload size = %d, page length = %d",
+			 payload_size,
+			 length);
+		if (length < payload_size) {
+			AMI_WARN(amc_ctrl_ctxt,
+				 "Data request length is %d but allocated length is %d",
+				 payload_size,
+				 length);
+			payload_size = length;
+		}
+
+		/* Copy payload data to address */
+		memcpy_gcq_payload_to_device(amc_ctrl_ctxt, payload_address, data_buf, data_size);
+	}
+	break;
+
 	case AMC_CMD_ID_SENSOR:
 	{
 		if (acquire_gcq_log_page_sema(amc_ctrl_ctxt,
@@ -1475,6 +1507,31 @@ int submit_gcq_command(struct amc_control_ctxt	*amc_ctrl_ctxt,
 		pdi_download_request.length = payload_size;
 		pdi_download_request.address = payload_address;
 		pdi_download_request.boot_device = PDI_BOOT_DEVICE(flags);
+		pdi_download_request.partial = false;
+
+		/* Using the `flags` argument to select the partition. */
+		if (PDI_PARTITION(flags) != FPT_UPDATE_FLAG)
+			pdi_download_request.partition = PDI_PARTITION(flags);
+		else
+			pdi_download_request.partition = FPT_UPDATE_MAGIC;
+
+		pdi_download_request.last_chunk = PDI_CHUNK_IS_LAST(flags);
+		pdi_download_request.chunk = PDI_CHUNK(flags);
+		pdi_download_request.chunk_size = PDI_CHUNK_SIZE;
+		/* Set longer timeout for the PDI download */
+		amc_proxy_cmd->cmd_timeout_jiffies = jiffies + REQUEST_DOWNLOAD_TIMEOUT;
+		ret = amc_proxy_request_pdi_download(amc_proxy_cmd, &pdi_download_request);
+
+	}
+	break;
+
+	case AMC_CMD_ID_DOWNLOAD_PARTIAL_PDI:
+	{
+		struct amc_proxy_pdi_download_request pdi_download_request = { 0 };
+		pdi_download_request.length = payload_size;
+		pdi_download_request.address = payload_address;
+		pdi_download_request.boot_device = PDI_BOOT_DEVICE(flags);
+		pdi_download_request.partial = true;
 
 		/* Using the `flags` argument to select the partition. */
 		if (PDI_PARTITION(flags) != FPT_UPDATE_FLAG)
@@ -1674,6 +1731,9 @@ int submit_gcq_command(struct amc_control_ctxt	*amc_ctrl_ctxt,
 		ret = amc_proxy_get_response_debug_verbosity(amc_proxy_cmd);
 		break;
 
+	case AMC_CMD_ID_DOWNLOAD_PARTIAL_PDI:
+		ret = amc_proxy_get_response_pdi_download(amc_proxy_cmd);
+		break;
 	default:
 		AMI_ERR(amc_ctrl_ctxt, "Unsupported response %d", cmd_id);
 		break;
diff --git a/sw/AMI/driver/ami_amc_control.h b/sw/AMI/driver/ami_amc_control.h
index 5828031..75ca259 100644
--- a/sw/AMI/driver/ami_amc_control.h
+++ b/sw/AMI/driver/ami_amc_control.h
@@ -140,6 +140,7 @@ enum gcq_submit_cmd_req {
 	GCQ_SUBMIT_CMD_DOWNLOAD_PDI			= 0x04,
 	GCQ_SUBMIT_CMD_DEVICE_BOOT			= 0x05,
 	GCQ_SUBMIT_CMD_COPY_PARTITION			= 0x06,
+	GCQ_SUBMIT_CMD_DOWNLOAD_PARTIAL_PDI		= 0x07,
 	GCQ_SUBMIT_CMD_GET_INLET_TEMP_SENSOR		= 0x10,
 	GCQ_SUBMIT_CMD_GET_OUTLET_TEMP_SENSOR		= 0x11,
 	GCQ_SUBMIT_CMD_GET_BOARD_TEMP_SENSOR		= 0x12,
@@ -359,6 +360,7 @@ enum amc_cmd_id {
 	AMC_CMD_ID_EEPROM_READ_WRITE,
 	AMC_CMD_ID_MODULE_READ_WRITE,
 	AMC_CMD_ID_DEBUG_VERBOSITY,
+	AMC_CMD_ID_DOWNLOAD_PARTIAL_PDI,
 
 	AMC_CMD_ID_MAX
 };
diff --git a/sw/AMI/driver/ami_cdev.c b/sw/AMI/driver/ami_cdev.c
index a332f7f..fbc5e4d 100644
--- a/sw/AMI/driver/ami_cdev.c
+++ b/sw/AMI/driver/ami_cdev.c
@@ -249,7 +249,8 @@ long dev_unlocked_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)
 					data.size,
 					data.boot_device,
 					data.partition,
-					efd_ctx
+					efd_ctx,
+					data.partial ? true : false
 				);
 		} else {
 			ret = -EFAULT;
diff --git a/sw/AMI/driver/ami_cdev.h b/sw/AMI/driver/ami_cdev.h
index d58e3e6..39a9b8b 100755
--- a/sw/AMI/driver/ami_cdev.h
+++ b/sw/AMI/driver/ami_cdev.h
@@ -43,6 +43,7 @@
  * @cap_override: Bypass permission checks. This may not apply to all IOCTL's.
  * @efd: File descriptor for event notifications (used for progress reporting when
  *     performing long running operations like PDI downloads) - optional
+ * @partial: Flag to indicate whether the PDI is partial or full.
  *
  * Note that addr can be an address to any arbitrary data type,
  * depending on the context. This struct is reused for the boot select
@@ -63,6 +64,7 @@ struct ami_ioc_data_payload {
 	uint32_t       dest_part;
 	bool           cap_override;
 	int            efd;
+	bool           partial;
 };
 
 /**
diff --git a/sw/AMI/driver/ami_program.c b/sw/AMI/driver/ami_program.c
index cd0bafc..2951de8 100644
--- a/sw/AMI/driver/ami_program.c
+++ b/sw/AMI/driver/ami_program.c
@@ -29,6 +29,7 @@
  * @boot_device: Target boot device.
  * @partition: Partition number to flash.
  * @efd_ctx: eventfd context for reporting progress (optional).
+ * @partial: Flag to indicate partial download.
  *
  * If `partition` is equal to `FPT_UPDATE_MAGIC` will update the FPT.
  *
@@ -71,7 +72,7 @@ static int do_image_download(struct amc_control_ctxt *amc_ctrl_ctxt, uint8_t *bu
 			bytes_to_write = (size - bytes_written);
 		else
 			bytes_to_write = (PDI_CHUNK_SIZE * PDI_CHUNK_MULTIPLIER);
-		
+
 		/*
 		 * Don't invalidate the boot tag if we're updating the FPT
 		 * or if there is only a single chunk.
@@ -153,23 +154,121 @@ static int do_image_download(struct amc_control_ctxt *amc_ctrl_ctxt, uint8_t *bu
 	return ret;
 }
 
+static int do_image_download_partial(struct amc_control_ctxt *amc_ctrl_ctxt, uint8_t *buf, uint32_t size,
+	uint8_t boot_device, uint32_t partition, struct eventfd_ctx *efd_ctx)
+{
+	int ret = SUCCESS;
+	uint16_t chunk = 0;
+	uint32_t bytes_written = 0;
+	uint32_t bytes_to_write = 0;
+	printk("Size: %d\n", size);
+	uint16_t num_chunks = (size + ((PDI_CHUNK_SIZE * PDI_CHUNK_MULTIPLIER) - 1)) /
+		(PDI_CHUNK_SIZE * PDI_CHUNK_MULTIPLIER);
+	printk("num_chunks = %d\n", num_chunks);
+	if (!size || !amc_ctrl_ctxt || !buf)
+		return -EINVAL;
+
+	AMI_VDBG(
+		amc_ctrl_ctxt,
+		"Attempting to download partial PDI with image size %d, num_chunks = %d", size, num_chunks
+	);
+
+	while (bytes_written < size) {
+
+		if ((PDI_CHUNK_SIZE * PDI_CHUNK_MULTIPLIER) > (size - bytes_written))
+			bytes_to_write = (size - bytes_written);
+		else
+			bytes_to_write = (PDI_CHUNK_SIZE * PDI_CHUNK_MULTIPLIER);
+
+		/*
+		* This will copy the bitstream buffer into shared memory and submit
+		* the GCQ command. Using `flags` to pass in partition and chunk numbers.
+		*/
+		ret = submit_gcq_command(amc_ctrl_ctxt, GCQ_SUBMIT_CMD_DOWNLOAD_PARTIAL_PDI,
+			MK_PDI_FLAGS(boot_device, partition, chunk, false),
+			&buf[bytes_written], bytes_to_write);
+
+		if (ret)
+			break;
+
+		if (efd_ctx)
+			eventfd_signal(efd_ctx, bytes_to_write);
+
+		AMI_VDBG(
+			amc_ctrl_ctxt,
+			"Done with chunk %d",
+			chunk
+		);
+		chunk++;
+		bytes_written += bytes_to_write;
+	}
+
+	chunk = 0;
+	bytes_written = 0;
+	bytes_to_write = 0;
+
+	while (bytes_written < size) {
+
+		if ((PDI_CHUNK_SIZE * PDI_CHUNK_MULTIPLIER) > (size - bytes_written))
+			bytes_to_write = (size - bytes_written);
+		else
+			bytes_to_write = (PDI_CHUNK_SIZE * PDI_CHUNK_MULTIPLIER);
+
+		/*
+		* This will copy the bitstream buffer into shared memory and submit
+		* the GCQ command. Using `flags` to pass in partition and chunk numbers.
+		*/
+		ret = submit_gcq_command(amc_ctrl_ctxt, GCQ_SUBMIT_CMD_DOWNLOAD_PARTIAL_PDI,
+			MK_PDI_FLAGS(boot_device, partition, chunk, (chunk == (num_chunks - 1))),
+			&buf[bytes_written], bytes_to_write);
+
+		if (ret)
+			break;
+
+		if (efd_ctx)
+			eventfd_signal(efd_ctx, bytes_to_write);
+
+		AMI_VDBG(
+			amc_ctrl_ctxt,
+			"Done with chunk %d",
+			chunk
+		);
+		chunk++;
+		bytes_written += bytes_to_write;
+	}
+
+	if (ret)
+		AMI_ERR(amc_ctrl_ctxt, "Failed to download partial PDI, ret code: %d", ret);
+
+	return ret;
+}
+
 /*
  * Download a PDI bitstream.
  */
 int download_pdi(struct amc_control_ctxt *amc_ctrl_ctxt, uint8_t *buf, uint32_t size,
-	uint8_t boot_device, uint32_t partition, struct eventfd_ctx *efd_ctx)
+	uint8_t boot_device, uint32_t partition, struct eventfd_ctx *efd_ctx, uint8_t partial)
 {
 	if (!amc_ctrl_ctxt || !size || !buf || (partition == FPT_UPDATE_MAGIC))
 		return -EINVAL;
-
-	return do_image_download(
-		amc_ctrl_ctxt,
-		buf,
-		size,
-		boot_device,
-		partition,
-		efd_ctx
-	);
+	if (!partial)
+		return do_image_download(
+			amc_ctrl_ctxt,
+			buf,
+			size,
+			boot_device,
+			partition,
+			efd_ctx
+		);
+	else
+		return do_image_download_partial(
+			amc_ctrl_ctxt,
+			buf,
+			size,
+			boot_device,
+			partition,
+			efd_ctx
+		);
 }
 
 /*
diff --git a/sw/AMI/driver/ami_program.h b/sw/AMI/driver/ami_program.h
index 87da637..4bec2d8 100644
--- a/sw/AMI/driver/ami_program.h
+++ b/sw/AMI/driver/ami_program.h
@@ -66,11 +66,12 @@
  * @boot_device: Target boot device.
  * @partition: Partition number to flash.
  * @efd_ctx: eventfd context for reporting progress (optional).
+ * @partial: Flag to indicate whether the PDI is partial or full.
  * 
  * Return: 0 or negative error code.
  */
 int download_pdi(struct amc_control_ctxt *amc_ctrl_ctxt, uint8_t *buf, uint32_t size,
-	uint8_t boot_device, uint32_t partition, struct eventfd_ctx *efd_ctx);
+	uint8_t boot_device, uint32_t partition, struct eventfd_ctx *efd_ctx, uint8_t partial);
 
 /**
  * update_fpt() - Download a PDI containing an FPT onto a device.
diff --git a/sw/AMI/scripts/gen_package.py b/sw/AMI/scripts/gen_package.py
index 01f401e..a81d169 100755
--- a/sw/AMI/scripts/gen_package.py
+++ b/sw/AMI/scripts/gen_package.py
@@ -381,7 +381,7 @@ def main(args):
             step = 'driver compilation confidence check'
             start_time = start_step('BUILD_DRIVER', step)
 
-            build_driver = 'cd driver && make clean && make'
+            build_driver = 'cd driver && make'
             exec_step_cmd('BUILD_CHECK_DRIVER', step, build_driver, shell=True, cwd=PROJECT_DIR)
             check_output_file_exists('BUILD_CHECK_DRIVER', join(PROJECT_DIR, 'driver', 'ami.ko'))
 
